// {{ project_description }}
// Generated by the homelab-platform go-service scaffold
package main

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/go-chi/chi/v5/middleware"
	"github.com/kelseyhightower/envconfig"
{%- if include_grpc %}
	"net"

	"google.golang.org/grpc"
{%- endif %}
)

// Config holds the application configuration loaded from environment variables
type Config struct {
	Port            int    `envconfig:"PORT" default:"{{ http_port }}"`
	LogLevel        string `envconfig:"LOG_LEVEL" default:"info"`
	ShutdownTimeout int    `envconfig:"SHUTDOWN_TIMEOUT" default:"30"`
{%- if include_grpc %}

	// gRPC configuration
	GRPCPort        int    `envconfig:"GRPC_PORT" default:"{{ grpc_port }}"`
	GRPCEnabled     bool   `envconfig:"GRPC_ENABLED" default:"true"`
{%- endif %}
{%- if include_database %}

	// Database configuration
	DatabaseURL     string `envconfig:"DATABASE_URL" required:"true"`
	MaxOpenConns    int    `envconfig:"DB_MAX_OPEN_CONNS" default:"25"`
	MaxIdleConns    int    `envconfig:"DB_MAX_IDLE_CONNS" default:"5"`
	ConnMaxLifetime int    `envconfig:"DB_CONN_MAX_LIFETIME" default:"300"` // seconds
{%- endif %}
{%- if include_storage %}

	// Azure Storage configuration (credentials from Crossplane connection secret)
	StorageAccountName   string `envconfig:"AZURE_STORAGE_ACCOUNT_NAME"`
	StorageAccountKey    string `envconfig:"AZURE_STORAGE_ACCOUNT_KEY"`
	StorageContainerName string `envconfig:"AZURE_STORAGE_CONTAINER_NAME"`
{%- endif %}
{%- if include_keyvault %}

	// Azure Key Vault configuration
	KeyVaultURL     string `envconfig:"AZURE_KEYVAULT_URL"`
{%- endif %}
}

func main() {
	// Load configuration from environment
	var cfg Config
	if err := envconfig.Process("", &cfg); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to load configuration: %v\n", err)
		os.Exit(1)
	}

	// Setup structured logging
	logLevel := parseLogLevel(cfg.LogLevel)
	logger := slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
		Level: logLevel,
	}))
	slog.SetDefault(logger)

	slog.Info("Starting {{ project_name }}",
		"port", cfg.Port,
		"log_level", cfg.LogLevel,
	)

	// Initialize router
	r := setupRouter()

	// Create HTTP server
	srv := &http.Server{
		Addr:         fmt.Sprintf(":%d", cfg.Port),
		Handler:      r,
		ReadTimeout:  15 * time.Second,
		WriteTimeout: 15 * time.Second,
		IdleTimeout:  60 * time.Second,
	}

	// Start server in goroutine
	serverErrors := make(chan error, 1)
	go func() {
		slog.Info("HTTP server listening", "addr", srv.Addr)
		serverErrors <- srv.ListenAndServe()
	}()
{%- if include_grpc %}

	// Start gRPC server if enabled
	var grpcServer *grpc.Server
	if cfg.GRPCEnabled {
		var err error
		grpcServer, err = startGRPCServer(cfg)
		if err != nil {
			slog.Error("Failed to start gRPC server", "error", err)
			os.Exit(1)
		}
	}
{%- endif %}

	// Setup graceful shutdown
	shutdown := make(chan os.Signal, 1)
	signal.Notify(shutdown, os.Interrupt, syscall.SIGTERM)

	// Block until shutdown signal or server error
	select {
	case err := <-serverErrors:
		if err != nil && !errors.Is(err, http.ErrServerClosed) {
			slog.Error("Server error", "error", err)
			os.Exit(1)
		}
	case sig := <-shutdown:
		slog.Info("Shutdown signal received", "signal", sig)

		// Create shutdown context with timeout
		ctx, cancel := context.WithTimeout(context.Background(), time.Duration(cfg.ShutdownTimeout)*time.Second)
		defer cancel()

		// Attempt graceful shutdown of HTTP server
		if err := srv.Shutdown(ctx); err != nil {
			slog.Error("Graceful shutdown failed, forcing", "error", err)
			if err := srv.Close(); err != nil {
				slog.Error("Force close failed", "error", err)
			}
		}
{%- if include_grpc %}

		// Gracefully stop gRPC server
		if grpcServer != nil {
			slog.Info("Stopping gRPC server")
			grpcServer.GracefulStop()
		}
{%- endif %}
		slog.Info("Shutdown complete")
	}
}

// setupRouter configures the Chi router with middleware and routes
func setupRouter() *chi.Mux {
	r := chi.NewRouter()

	// Global middleware
	r.Use(middleware.RequestID)
	r.Use(middleware.RealIP)
	r.Use(loggerMiddleware)
	r.Use(middleware.Recoverer)
	r.Use(middleware.Timeout(60 * time.Second))

	// Health and readiness endpoints (required by Gatekeeper policy)
	r.Get("/health", healthHandler)
	r.Get("/ready", readyHandler)

	// TODO: Add your application routes here
	// Example:
	// r.Route("/api/v1", func(r chi.Router) {
	//     r.Get("/users", listUsersHandler)
	//     r.Post("/users", createUserHandler)
	// })

	return r
}

// loggerMiddleware logs HTTP requests with structured logging
func loggerMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()

		ww := middleware.NewWrapResponseWriter(w, r.ProtoMajor)
		next.ServeHTTP(ww, r)

		slog.Info("HTTP request",
			"method", r.Method,
			"path", r.URL.Path,
			"status", ww.Status(),
			"bytes", ww.BytesWritten(),
			"duration_ms", time.Since(start).Milliseconds(),
			"request_id", middleware.GetReqID(r.Context()),
			"remote_addr", r.RemoteAddr,
		)
	})
}

// healthHandler returns 200 OK if the service is running (liveness probe)
func healthHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write([]byte(`{"status":"ok"}`))
}

// readyHandler returns 200 OK if the service is ready to accept traffic (readiness probe)
func readyHandler(w http.ResponseWriter, r *http.Request) {
	// TODO: Add actual readiness checks for your dependencies
	// Examples:
	// - Database connectivity check
	// - External API reachability
	// - Required environment variables validation
	// - Cache/Redis connectivity
	//
	// If any dependency is unavailable, return 503 Service Unavailable
	// This allows Kubernetes to stop routing traffic during transient failures

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write([]byte(`{"status":"ready"}`))
}

// parseLogLevel converts string log level to slog.Level
func parseLogLevel(level string) slog.Level {
	switch level {
	case "debug":
		return slog.LevelDebug
	case "info":
		return slog.LevelInfo
	case "warn":
		return slog.LevelWarn
	case "error":
		return slog.LevelError
	default:
		return slog.LevelInfo
	}
}
{%- if include_grpc %}

// startGRPCServer initializes and starts the gRPC server
func startGRPCServer(cfg Config) (*grpc.Server, error) {
	lis, err := net.Listen("tcp", fmt.Sprintf(":%d", cfg.GRPCPort))
	if err != nil {
		return nil, fmt.Errorf("failed to listen on gRPC port: %w", err)
	}

	// Create gRPC server with common options
	grpcServer := grpc.NewServer(
		grpc.MaxRecvMsgSize(4 * 1024 * 1024), // 4MB max message size
		grpc.ConnectionTimeout(30 * time.Second),
	)

	// TODO: Register your gRPC services here
	// Example:
	// pb.RegisterYourServiceServer(grpcServer, &yourServiceImpl{})

	// Start server in goroutine
	go func() {
		slog.Info("gRPC server listening", "port", cfg.GRPCPort)
		if err := grpcServer.Serve(lis); err != nil {
			slog.Error("gRPC server error", "error", err)
		}
	}()

	return grpcServer, nil
}
{% endif %}
