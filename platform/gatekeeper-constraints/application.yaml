## Gatekeeper Constraints — Argo CD Application
##
## Applies only Constraint manifests AFTER the ConstraintTemplate CRDs have been
## registered (wave 6 > wave 5).
##
## This is the third of THREE Gatekeeper Applications:
##   Wave 4: gatekeeper (Helm — controller + webhook)
##   Wave 5: gatekeeper-templates (ConstraintTemplates → CRD registration)
##   Wave 6: gatekeeper-constraints (this Application — Constraint instances)
##
## Why three Applications:
##   - ConstraintTemplate CRDs are registered asynchronously by the Gatekeeper
##     controller after the template objects are admitted.
##   - Constraint objects fail to sync if their corresponding CRD doesn't exist yet.
##   - Two-Application approach (templates + constraints combined) still fails because
##     Argo CD attempts all resources in a single Application simultaneously, only
##     ordering them by sync-wave within a single sync operation.
##   - Three-Application approach (mirroring Crossplane's pattern) ensures templates
##     are fully processed before constraints are ever attempted.
##
## SkipDryRunOnMissingResource=true is belt-and-suspenders for any remaining timing
## gaps — selfHeal will retry if the first sync attempt races the CRD registration.
##
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  annotations:
    argocd.argoproj.io/sync-wave: "6"
  labels:
    app.kubernetes.io/managed-by: argocd
    app.kubernetes.io/name: gatekeeper-constraints
    app.kubernetes.io/part-of: platform
  name: gatekeeper-constraints
  namespace: argocd
spec:
  destination:
    namespace: gatekeeper-system
    server: https://kubernetes.default.svc
  project: platform
  source:
    repoURL: https://github.com/rodmhgl/homelab-platform
    targetRevision: main
    path: platform/gatekeeper-constraints
    directory:
      recurse: true
      exclude: "application.yaml"
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - ServerSideApply=true
      - SkipDryRunOnMissingResource=true
