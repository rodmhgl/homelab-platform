## Falco Custom Rules ConfigMap
##
## This ConfigMap contains custom Falco rules specific to the homelab platform.
## It is mounted into Falco pods at /etc/falco/rules.d/ and loaded automatically.
##
## Falco Rule Syntax:
## - rule: (string) Rule name
##   desc: (string) Description of what the rule detects
##   condition: (string) Boolean expression using Falco filter syntax
##   output: (string) Alert message with field interpolation
##   priority: (enum) WARNING, ERROR, CRITICAL, etc.
##   tags: (list) Classification tags for filtering/routing
##
## Falco Filter Fields (commonly used):
## - evt.type: syscall type (execve, open, connect, etc.)
## - proc.name: process name
## - container.id: container ID (if running in container)
## - container.name: container name
## - fd.name: file descriptor name (for file operations)
## - user.name: username executing the syscall
## - proc.cmdline: full command line
##
## Macros and Lists:
## Falco rules can reference macros (reusable conditions) and lists (arrays of values).
## We define custom macros here to make rules more readable.
##
apiVersion: v1
kind: ConfigMap
metadata:
  name: falco-custom-rules
  namespace: falco
  labels:
    app.kubernetes.io/name: falco
    app.kubernetes.io/part-of: platform
    app.kubernetes.io/managed-by: argocd
data:
  custom-rules.yaml: |
    ##############################################################################
    ## Custom Macros and Lists
    ##############################################################################

    ## List of shell binaries we want to detect
    - list: shell_binaries
      items: [bash, sh, zsh, fish, csh, ksh, tcsh, dash]

    ## List of sensitive files that should rarely be accessed
    - list: sensitive_files
      items:
        - /etc/shadow
        - /etc/sudoers
        - /etc/pam.d
        - /etc/security
        - /root/.ssh
        - /root/.aws
        - /root/.kube/config

    ## Macro: Container is running (not just spawned)
    - macro: container
      condition: (container.id != host)

    ## Macro: Production workload namespaces (exclude platform namespaces)
    - macro: production_namespace
      condition: >
        (k8s.ns.name exists and
         k8s.ns.name != "kube-system" and
         k8s.ns.name != "kube-public" and
         k8s.ns.name != "kube-node-lease" and
         k8s.ns.name != "argocd" and
         k8s.ns.name != "crossplane-system" and
         k8s.ns.name != "gatekeeper-system" and
         k8s.ns.name != "trivy-system" and
         k8s.ns.name != "falco" and
         k8s.ns.name != "external-secrets" and
         k8s.ns.name != "monitoring")

    ## Macro: User is not root
    - macro: non_root_user
      condition: (user.uid != 0)

    ## Macro: Interactive shell (spawned by user, not init/systemd)
    - macro: shell_procs
      condition: (proc.name in (shell_binaries))

    ## Macro: Sensitive file read
    - macro: sensitive_file_read
      condition: (fd.name in (sensitive_files) and evt.is_open_read=true)

    ##############################################################################
    ## Rule 1: Unexpected Shell in Container
    ##############################################################################
    ## Detects when a shell is spawned inside a production container.
    ## This is often a sign of:
    ## - Attacker gaining interactive access after exploit
    ## - kubectl exec abuse
    ## - Misconfigured health checks using shell commands
    ##
    ## Exceptions:
    ## - CI/CD containers (often run shell scripts)
    ## - Debug containers (explicitly allowed for troubleshooting)
    ##
    ## Priority: WARNING (not critical, but worth investigating)
    ##
    - rule: Unexpected Shell Spawned in Container
      desc: >
        A shell was spawned inside a production container. This may indicate
        an attacker gaining interactive access, kubectl exec abuse, or a
        misconfigured application health check. Investigate the process tree
        and parent command to determine legitimacy.
      condition: >
        spawned_process and
        container and
        production_namespace and
        shell_procs and
        proc.pname exists and
        proc.pname != "sh" and
        proc.pname != "bash" and
        proc.aname[2] != "docker"
      output: >
        Shell spawned in production container
        (container=%container.name
         namespace=%k8s.ns.name
         pod=%k8s.pod.name
         shell=%proc.name
         parent=%proc.pname
         cmdline=%proc.cmdline
         user=%user.name
         uid=%user.uid
         image=%container.image.repository)
      priority: WARNING
      tags:
        - container
        - shell
        - mitre_execution
        - runtime_security

    ##############################################################################
    ## Rule 2: Sensitive File Read
    ##############################################################################
    ## Detects when sensitive system files are accessed.
    ## Sensitive files include:
    ## - /etc/shadow (password hashes)
    ## - /etc/sudoers (sudo configuration)
    ## - /root/.ssh (SSH private keys)
    ## - /root/.kube/config (Kubernetes credentials)
    ##
    ## Legitimate access to these files is rare in containerized workloads.
    ## If detected, it may indicate:
    ## - Credential harvesting attack
    ## - Privilege escalation attempt
    ## - Misconfigured application trying to access host files
    ##
    ## Priority: ERROR (higher than shell spawning, as this is more suspicious)
    ##
    - rule: Sensitive File Read in Container
      desc: >
        A process inside a container attempted to read a sensitive system file
        (e.g., /etc/shadow, SSH keys, Kubernetes config). This is highly
        suspicious in containerized environments and may indicate credential
        theft or privilege escalation.
      condition: >
        open_read and
        container and
        production_namespace and
        sensitive_file_read and
        not proc.name in (trusted_system_binaries)
      output: >
        Sensitive file read detected in container
        (file=%fd.name
         container=%container.name
         namespace=%k8s.ns.name
         pod=%k8s.pod.name
         process=%proc.name
         cmdline=%proc.cmdline
         user=%user.name
         uid=%user.uid
         parent=%proc.pname
         image=%container.image.repository)
      priority: ERROR
      tags:
        - container
        - credential_access
        - mitre_credential_access
        - runtime_security
        - sensitive_file

    ##############################################################################
    ## Rule 3: Container Drift Detection
    ##############################################################################
    ## Detects when binaries are written to container filesystems.
    ## Containers should be immutable — if a binary is written after start,
    ## it may indicate:
    ## - Attacker downloading malware
    ## - Misconfigured CI/CD pipeline
    ## - Application doing unexpected self-updates
    ##
    ## Priority: WARNING (investigate, but not always malicious)
    ##
    - rule: Binary Written to Container Filesystem
      desc: >
        A binary was written to a container's filesystem after it started.
        Containers should be immutable. This may indicate malware installation,
        cryptocurrency mining, or a misconfigured CI/CD pipeline.
      condition: >
        open_write and
        container and
        production_namespace and
        fd.name startswith "/bin/" or
        fd.name startswith "/usr/bin/" or
        fd.name startswith "/usr/local/bin/" or
        fd.name startswith "/sbin/" or
        fd.name startswith "/usr/sbin/"
      output: >
        Binary written to container filesystem
        (file=%fd.name
         container=%container.name
         namespace=%k8s.ns.name
         pod=%k8s.pod.name
         process=%proc.name
         cmdline=%proc.cmdline
         user=%user.name
         parent=%proc.pname
         image=%container.image.repository)
      priority: WARNING
      tags:
        - container
        - drift
        - mitre_persistence
        - runtime_security

    ##############################################################################
    ## Rule 4: Unexpected Network Connection
    ##############################################################################
    ## Detects outbound connections to unexpected ports.
    ## Many attacks involve C2 (command and control) traffic on non-standard ports.
    ##
    ## This rule triggers on outbound connections to ports commonly used by:
    ## - IRC (6667) — old-school C2
    ## - Bitcoin mining pools (3333, 8333) — cryptomining
    ## - Tor (9001, 9030) — anonymization networks
    ##
    ## Priority: WARNING (investigate, may be legitimate tools)
    ##
    - list: suspicious_outbound_ports
      items: [6667, 3333, 8333, 9001, 9030]

    - rule: Unexpected Network Connection from Container
      desc: >
        A container established an outbound network connection to a suspicious port.
        This may indicate command-and-control traffic, cryptocurrency mining,
        or data exfiltration.
      condition: >
        outbound and
        container and
        production_namespace and
        fd.sport in (suspicious_outbound_ports)
      output: >
        Suspicious outbound connection from container
        (port=%fd.sport
         dest_ip=%fd.rip
         dest_port=%fd.rport
         container=%container.name
         namespace=%k8s.ns.name
         pod=%k8s.pod.name
         process=%proc.name
         cmdline=%proc.cmdline
         user=%user.name
         image=%container.image.repository)
      priority: WARNING
      tags:
        - container
        - network
        - mitre_command_and_control
        - runtime_security
